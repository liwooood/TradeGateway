// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tradelog.proto

#ifndef PROTOBUF_tradelog_2eproto__INCLUDED
#define PROTOBUF_tradelog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace Trade {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tradelog_2eproto();
void protobuf_AssignDesc_tradelog_2eproto();
void protobuf_ShutdownFile_tradelog_2eproto();

class TradeLog;

enum TradeLog_LogLevel {
  TradeLog_LogLevel_DEBUG_LEVEL = 0,
  TradeLog_LogLevel_INFO_LEVEL = 1,
  TradeLog_LogLevel_WARN_LEVEL = 2,
  TradeLog_LogLevel_ERROR_LEVEL = 3
};
bool TradeLog_LogLevel_IsValid(int value);
const TradeLog_LogLevel TradeLog_LogLevel_LogLevel_MIN = TradeLog_LogLevel_DEBUG_LEVEL;
const TradeLog_LogLevel TradeLog_LogLevel_LogLevel_MAX = TradeLog_LogLevel_ERROR_LEVEL;
const int TradeLog_LogLevel_LogLevel_ARRAYSIZE = TradeLog_LogLevel_LogLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradeLog_LogLevel_descriptor();
inline const ::std::string& TradeLog_LogLevel_Name(TradeLog_LogLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradeLog_LogLevel_descriptor(), value);
}
inline bool TradeLog_LogLevel_Parse(
    const ::std::string& name, TradeLog_LogLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradeLog_LogLevel>(
    TradeLog_LogLevel_descriptor(), name, value);
}
// ===================================================================

class TradeLog : public ::google::protobuf::Message {
 public:
  TradeLog();
  virtual ~TradeLog();
  
  TradeLog(const TradeLog& from);
  
  inline TradeLog& operator=(const TradeLog& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeLog& default_instance();
  
  void Swap(TradeLog* other);
  
  // implements Message ----------------------------------------------
  
  TradeLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradeLog& from);
  void MergeFrom(const TradeLog& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef TradeLog_LogLevel LogLevel;
  static const LogLevel DEBUG_LEVEL = TradeLog_LogLevel_DEBUG_LEVEL;
  static const LogLevel INFO_LEVEL = TradeLog_LogLevel_INFO_LEVEL;
  static const LogLevel WARN_LEVEL = TradeLog_LogLevel_WARN_LEVEL;
  static const LogLevel ERROR_LEVEL = TradeLog_LogLevel_ERROR_LEVEL;
  static inline bool LogLevel_IsValid(int value) {
    return TradeLog_LogLevel_IsValid(value);
  }
  static const LogLevel LogLevel_MIN =
    TradeLog_LogLevel_LogLevel_MIN;
  static const LogLevel LogLevel_MAX =
    TradeLog_LogLevel_LogLevel_MAX;
  static const int LogLevel_ARRAYSIZE =
    TradeLog_LogLevel_LogLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LogLevel_descriptor() {
    return TradeLog_LogLevel_descriptor();
  }
  static inline const ::std::string& LogLevel_Name(LogLevel value) {
    return TradeLog_LogLevel_Name(value);
  }
  static inline bool LogLevel_Parse(const ::std::string& name,
      LogLevel* value) {
    return TradeLog_LogLevel_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string sysNo = 1;
  inline bool has_sysno() const;
  inline void clear_sysno();
  static const int kSysNoFieldNumber = 1;
  inline const ::std::string& sysno() const;
  inline void set_sysno(const ::std::string& value);
  inline void set_sysno(const char* value);
  inline void set_sysno(const char* value, size_t size);
  inline ::std::string* mutable_sysno();
  inline ::std::string* release_sysno();
  
  // required string busiType = 2;
  inline bool has_busitype() const;
  inline void clear_busitype();
  static const int kBusiTypeFieldNumber = 2;
  inline const ::std::string& busitype() const;
  inline void set_busitype(const ::std::string& value);
  inline void set_busitype(const char* value);
  inline void set_busitype(const char* value, size_t size);
  inline ::std::string* mutable_busitype();
  inline ::std::string* release_busitype();
  
  // required string sysVer = 3;
  inline bool has_sysver() const;
  inline void clear_sysver();
  static const int kSysVerFieldNumber = 3;
  inline const ::std::string& sysver() const;
  inline void set_sysver(const ::std::string& value);
  inline void set_sysver(const char* value);
  inline void set_sysver(const char* value, size_t size);
  inline ::std::string* mutable_sysver();
  inline ::std::string* release_sysver();
  
  // required string account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  
  // required .Trade.TradeLog.LogLevel level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::Trade::TradeLog_LogLevel level() const;
  inline void set_level(::Trade::TradeLog_LogLevel value);
  
  // required string gatewayip = 6;
  inline bool has_gatewayip() const;
  inline void clear_gatewayip();
  static const int kGatewayipFieldNumber = 6;
  inline const ::std::string& gatewayip() const;
  inline void set_gatewayip(const ::std::string& value);
  inline void set_gatewayip(const char* value);
  inline void set_gatewayip(const char* value, size_t size);
  inline ::std::string* mutable_gatewayip();
  inline ::std::string* release_gatewayip();
  
  // required string gatewayport = 7;
  inline bool has_gatewayport() const;
  inline void clear_gatewayport();
  static const int kGatewayportFieldNumber = 7;
  inline const ::std::string& gatewayport() const;
  inline void set_gatewayport(const ::std::string& value);
  inline void set_gatewayport(const char* value);
  inline void set_gatewayport(const char* value, size_t size);
  inline ::std::string* mutable_gatewayport();
  inline ::std::string* release_gatewayport();
  
  // required string gtip = 8;
  inline bool has_gtip() const;
  inline void clear_gtip();
  static const int kGtipFieldNumber = 8;
  inline const ::std::string& gtip() const;
  inline void set_gtip(const ::std::string& value);
  inline void set_gtip(const char* value);
  inline void set_gtip(const char* value, size_t size);
  inline ::std::string* mutable_gtip();
  inline ::std::string* release_gtip();
  
  // required string gtport = 9;
  inline bool has_gtport() const;
  inline void clear_gtport();
  static const int kGtportFieldNumber = 9;
  inline const ::std::string& gtport() const;
  inline void set_gtport(const ::std::string& value);
  inline void set_gtport(const char* value);
  inline void set_gtport(const char* value, size_t size);
  inline ::std::string* mutable_gtport();
  inline ::std::string* release_gtport();
  
  // required string recvtime = 10;
  inline bool has_recvtime() const;
  inline void clear_recvtime();
  static const int kRecvtimeFieldNumber = 10;
  inline const ::std::string& recvtime() const;
  inline void set_recvtime(const ::std::string& value);
  inline void set_recvtime(const char* value);
  inline void set_recvtime(const char* value, size_t size);
  inline ::std::string* mutable_recvtime();
  inline ::std::string* release_recvtime();
  
  // required string begintime = 11;
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBegintimeFieldNumber = 11;
  inline const ::std::string& begintime() const;
  inline void set_begintime(const ::std::string& value);
  inline void set_begintime(const char* value);
  inline void set_begintime(const char* value, size_t size);
  inline ::std::string* mutable_begintime();
  inline ::std::string* release_begintime();
  
  // required int64 runtime = 12;
  inline bool has_runtime() const;
  inline void clear_runtime();
  static const int kRuntimeFieldNumber = 12;
  inline ::google::protobuf::int64 runtime() const;
  inline void set_runtime(::google::protobuf::int64 value);
  
  // required string sendtime = 13;
  inline bool has_sendtime() const;
  inline void clear_sendtime();
  static const int kSendtimeFieldNumber = 13;
  inline const ::std::string& sendtime() const;
  inline void set_sendtime(const ::std::string& value);
  inline void set_sendtime(const char* value);
  inline void set_sendtime(const char* value, size_t size);
  inline ::std::string* mutable_sendtime();
  inline ::std::string* release_sendtime();
  
  // required string enc_request = 14;
  inline bool has_enc_request() const;
  inline void clear_enc_request();
  static const int kEncRequestFieldNumber = 14;
  inline const ::std::string& enc_request() const;
  inline void set_enc_request(const ::std::string& value);
  inline void set_enc_request(const char* value);
  inline void set_enc_request(const char* value, size_t size);
  inline ::std::string* mutable_enc_request();
  inline ::std::string* release_enc_request();
  
  // required string request = 15;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 15;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const char* value, size_t size);
  inline ::std::string* mutable_request();
  inline ::std::string* release_request();
  
  // required int32 status = 16;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 16;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // required string retcode = 17;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 17;
  inline const ::std::string& retcode() const;
  inline void set_retcode(const ::std::string& value);
  inline void set_retcode(const char* value);
  inline void set_retcode(const char* value, size_t size);
  inline ::std::string* mutable_retcode();
  inline ::std::string* release_retcode();
  
  // required string retmsg = 18;
  inline bool has_retmsg() const;
  inline void clear_retmsg();
  static const int kRetmsgFieldNumber = 18;
  inline const ::std::string& retmsg() const;
  inline void set_retmsg(const ::std::string& value);
  inline void set_retmsg(const char* value);
  inline void set_retmsg(const char* value, size_t size);
  inline ::std::string* mutable_retmsg();
  inline ::std::string* release_retmsg();
  
  // required string response = 19;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 19;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const char* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  
  // required string enc_response = 20;
  inline bool has_enc_response() const;
  inline void clear_enc_response();
  static const int kEncResponseFieldNumber = 20;
  inline const ::std::string& enc_response() const;
  inline void set_enc_response(const ::std::string& value);
  inline void set_enc_response(const char* value);
  inline void set_enc_response(const char* value, size_t size);
  inline ::std::string* mutable_enc_response();
  inline ::std::string* release_enc_response();
  
  // required string ip = 21;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 21;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // required string funcid = 22;
  inline bool has_funcid() const;
  inline void clear_funcid();
  static const int kFuncidFieldNumber = 22;
  inline const ::std::string& funcid() const;
  inline void set_funcid(const ::std::string& value);
  inline void set_funcid(const char* value);
  inline void set_funcid(const char* value, size_t size);
  inline ::std::string* mutable_funcid();
  inline ::std::string* release_funcid();
  
  // required string counterType = 23;
  inline bool has_countertype() const;
  inline void clear_countertype();
  static const int kCounterTypeFieldNumber = 23;
  inline const ::std::string& countertype() const;
  inline void set_countertype(const ::std::string& value);
  inline void set_countertype(const char* value);
  inline void set_countertype(const char* value, size_t size);
  inline ::std::string* mutable_countertype();
  inline ::std::string* release_countertype();
  
  // @@protoc_insertion_point(class_scope:Trade.TradeLog)
 private:
  inline void set_has_sysno();
  inline void clear_has_sysno();
  inline void set_has_busitype();
  inline void clear_has_busitype();
  inline void set_has_sysver();
  inline void clear_has_sysver();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_gatewayip();
  inline void clear_has_gatewayip();
  inline void set_has_gatewayport();
  inline void clear_has_gatewayport();
  inline void set_has_gtip();
  inline void clear_has_gtip();
  inline void set_has_gtport();
  inline void clear_has_gtport();
  inline void set_has_recvtime();
  inline void clear_has_recvtime();
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_runtime();
  inline void clear_has_runtime();
  inline void set_has_sendtime();
  inline void clear_has_sendtime();
  inline void set_has_enc_request();
  inline void clear_has_enc_request();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_retmsg();
  inline void clear_has_retmsg();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_enc_response();
  inline void clear_has_enc_response();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_funcid();
  inline void clear_has_funcid();
  inline void set_has_countertype();
  inline void clear_has_countertype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sysno_;
  ::std::string* busitype_;
  ::std::string* sysver_;
  ::std::string* account_;
  ::std::string* gatewayip_;
  ::std::string* gatewayport_;
  ::std::string* gtip_;
  ::std::string* gtport_;
  ::std::string* recvtime_;
  int level_;
  ::google::protobuf::int32 status_;
  ::std::string* begintime_;
  ::google::protobuf::int64 runtime_;
  ::std::string* sendtime_;
  ::std::string* enc_request_;
  ::std::string* request_;
  ::std::string* retcode_;
  ::std::string* retmsg_;
  ::std::string* response_;
  ::std::string* enc_response_;
  ::std::string* ip_;
  ::std::string* funcid_;
  ::std::string* countertype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];
  
  friend void  protobuf_AddDesc_tradelog_2eproto();
  friend void protobuf_AssignDesc_tradelog_2eproto();
  friend void protobuf_ShutdownFile_tradelog_2eproto();
  
  void InitAsDefaultInstance();
  static TradeLog* default_instance_;
};
// ===================================================================


// ===================================================================

// TradeLog

// required string sysNo = 1;
inline bool TradeLog::has_sysno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeLog::set_has_sysno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeLog::clear_has_sysno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeLog::clear_sysno() {
  if (sysno_ != &::google::protobuf::internal::kEmptyString) {
    sysno_->clear();
  }
  clear_has_sysno();
}
inline const ::std::string& TradeLog::sysno() const {
  return *sysno_;
}
inline void TradeLog::set_sysno(const ::std::string& value) {
  set_has_sysno();
  if (sysno_ == &::google::protobuf::internal::kEmptyString) {
    sysno_ = new ::std::string;
  }
  sysno_->assign(value);
}
inline void TradeLog::set_sysno(const char* value) {
  set_has_sysno();
  if (sysno_ == &::google::protobuf::internal::kEmptyString) {
    sysno_ = new ::std::string;
  }
  sysno_->assign(value);
}
inline void TradeLog::set_sysno(const char* value, size_t size) {
  set_has_sysno();
  if (sysno_ == &::google::protobuf::internal::kEmptyString) {
    sysno_ = new ::std::string;
  }
  sysno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_sysno() {
  set_has_sysno();
  if (sysno_ == &::google::protobuf::internal::kEmptyString) {
    sysno_ = new ::std::string;
  }
  return sysno_;
}
inline ::std::string* TradeLog::release_sysno() {
  clear_has_sysno();
  if (sysno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysno_;
    sysno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string busiType = 2;
inline bool TradeLog::has_busitype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeLog::set_has_busitype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeLog::clear_has_busitype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeLog::clear_busitype() {
  if (busitype_ != &::google::protobuf::internal::kEmptyString) {
    busitype_->clear();
  }
  clear_has_busitype();
}
inline const ::std::string& TradeLog::busitype() const {
  return *busitype_;
}
inline void TradeLog::set_busitype(const ::std::string& value) {
  set_has_busitype();
  if (busitype_ == &::google::protobuf::internal::kEmptyString) {
    busitype_ = new ::std::string;
  }
  busitype_->assign(value);
}
inline void TradeLog::set_busitype(const char* value) {
  set_has_busitype();
  if (busitype_ == &::google::protobuf::internal::kEmptyString) {
    busitype_ = new ::std::string;
  }
  busitype_->assign(value);
}
inline void TradeLog::set_busitype(const char* value, size_t size) {
  set_has_busitype();
  if (busitype_ == &::google::protobuf::internal::kEmptyString) {
    busitype_ = new ::std::string;
  }
  busitype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_busitype() {
  set_has_busitype();
  if (busitype_ == &::google::protobuf::internal::kEmptyString) {
    busitype_ = new ::std::string;
  }
  return busitype_;
}
inline ::std::string* TradeLog::release_busitype() {
  clear_has_busitype();
  if (busitype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = busitype_;
    busitype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string sysVer = 3;
inline bool TradeLog::has_sysver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TradeLog::set_has_sysver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TradeLog::clear_has_sysver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TradeLog::clear_sysver() {
  if (sysver_ != &::google::protobuf::internal::kEmptyString) {
    sysver_->clear();
  }
  clear_has_sysver();
}
inline const ::std::string& TradeLog::sysver() const {
  return *sysver_;
}
inline void TradeLog::set_sysver(const ::std::string& value) {
  set_has_sysver();
  if (sysver_ == &::google::protobuf::internal::kEmptyString) {
    sysver_ = new ::std::string;
  }
  sysver_->assign(value);
}
inline void TradeLog::set_sysver(const char* value) {
  set_has_sysver();
  if (sysver_ == &::google::protobuf::internal::kEmptyString) {
    sysver_ = new ::std::string;
  }
  sysver_->assign(value);
}
inline void TradeLog::set_sysver(const char* value, size_t size) {
  set_has_sysver();
  if (sysver_ == &::google::protobuf::internal::kEmptyString) {
    sysver_ = new ::std::string;
  }
  sysver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_sysver() {
  set_has_sysver();
  if (sysver_ == &::google::protobuf::internal::kEmptyString) {
    sysver_ = new ::std::string;
  }
  return sysver_;
}
inline ::std::string* TradeLog::release_sysver() {
  clear_has_sysver();
  if (sysver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sysver_;
    sysver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string account = 4;
inline bool TradeLog::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TradeLog::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TradeLog::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TradeLog::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TradeLog::account() const {
  return *account_;
}
inline void TradeLog::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TradeLog::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TradeLog::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TradeLog::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .Trade.TradeLog.LogLevel level = 5;
inline bool TradeLog::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TradeLog::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TradeLog::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TradeLog::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::Trade::TradeLog_LogLevel TradeLog::level() const {
  return static_cast< ::Trade::TradeLog_LogLevel >(level_);
}
inline void TradeLog::set_level(::Trade::TradeLog_LogLevel value) {
  GOOGLE_DCHECK(::Trade::TradeLog_LogLevel_IsValid(value));
  set_has_level();
  level_ = value;
}

// required string gatewayip = 6;
inline bool TradeLog::has_gatewayip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TradeLog::set_has_gatewayip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TradeLog::clear_has_gatewayip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TradeLog::clear_gatewayip() {
  if (gatewayip_ != &::google::protobuf::internal::kEmptyString) {
    gatewayip_->clear();
  }
  clear_has_gatewayip();
}
inline const ::std::string& TradeLog::gatewayip() const {
  return *gatewayip_;
}
inline void TradeLog::set_gatewayip(const ::std::string& value) {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  gatewayip_->assign(value);
}
inline void TradeLog::set_gatewayip(const char* value) {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  gatewayip_->assign(value);
}
inline void TradeLog::set_gatewayip(const char* value, size_t size) {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  gatewayip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_gatewayip() {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  return gatewayip_;
}
inline ::std::string* TradeLog::release_gatewayip() {
  clear_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gatewayip_;
    gatewayip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string gatewayport = 7;
inline bool TradeLog::has_gatewayport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TradeLog::set_has_gatewayport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TradeLog::clear_has_gatewayport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TradeLog::clear_gatewayport() {
  if (gatewayport_ != &::google::protobuf::internal::kEmptyString) {
    gatewayport_->clear();
  }
  clear_has_gatewayport();
}
inline const ::std::string& TradeLog::gatewayport() const {
  return *gatewayport_;
}
inline void TradeLog::set_gatewayport(const ::std::string& value) {
  set_has_gatewayport();
  if (gatewayport_ == &::google::protobuf::internal::kEmptyString) {
    gatewayport_ = new ::std::string;
  }
  gatewayport_->assign(value);
}
inline void TradeLog::set_gatewayport(const char* value) {
  set_has_gatewayport();
  if (gatewayport_ == &::google::protobuf::internal::kEmptyString) {
    gatewayport_ = new ::std::string;
  }
  gatewayport_->assign(value);
}
inline void TradeLog::set_gatewayport(const char* value, size_t size) {
  set_has_gatewayport();
  if (gatewayport_ == &::google::protobuf::internal::kEmptyString) {
    gatewayport_ = new ::std::string;
  }
  gatewayport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_gatewayport() {
  set_has_gatewayport();
  if (gatewayport_ == &::google::protobuf::internal::kEmptyString) {
    gatewayport_ = new ::std::string;
  }
  return gatewayport_;
}
inline ::std::string* TradeLog::release_gatewayport() {
  clear_has_gatewayport();
  if (gatewayport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gatewayport_;
    gatewayport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string gtip = 8;
inline bool TradeLog::has_gtip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TradeLog::set_has_gtip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TradeLog::clear_has_gtip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TradeLog::clear_gtip() {
  if (gtip_ != &::google::protobuf::internal::kEmptyString) {
    gtip_->clear();
  }
  clear_has_gtip();
}
inline const ::std::string& TradeLog::gtip() const {
  return *gtip_;
}
inline void TradeLog::set_gtip(const ::std::string& value) {
  set_has_gtip();
  if (gtip_ == &::google::protobuf::internal::kEmptyString) {
    gtip_ = new ::std::string;
  }
  gtip_->assign(value);
}
inline void TradeLog::set_gtip(const char* value) {
  set_has_gtip();
  if (gtip_ == &::google::protobuf::internal::kEmptyString) {
    gtip_ = new ::std::string;
  }
  gtip_->assign(value);
}
inline void TradeLog::set_gtip(const char* value, size_t size) {
  set_has_gtip();
  if (gtip_ == &::google::protobuf::internal::kEmptyString) {
    gtip_ = new ::std::string;
  }
  gtip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_gtip() {
  set_has_gtip();
  if (gtip_ == &::google::protobuf::internal::kEmptyString) {
    gtip_ = new ::std::string;
  }
  return gtip_;
}
inline ::std::string* TradeLog::release_gtip() {
  clear_has_gtip();
  if (gtip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gtip_;
    gtip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string gtport = 9;
inline bool TradeLog::has_gtport() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TradeLog::set_has_gtport() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TradeLog::clear_has_gtport() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TradeLog::clear_gtport() {
  if (gtport_ != &::google::protobuf::internal::kEmptyString) {
    gtport_->clear();
  }
  clear_has_gtport();
}
inline const ::std::string& TradeLog::gtport() const {
  return *gtport_;
}
inline void TradeLog::set_gtport(const ::std::string& value) {
  set_has_gtport();
  if (gtport_ == &::google::protobuf::internal::kEmptyString) {
    gtport_ = new ::std::string;
  }
  gtport_->assign(value);
}
inline void TradeLog::set_gtport(const char* value) {
  set_has_gtport();
  if (gtport_ == &::google::protobuf::internal::kEmptyString) {
    gtport_ = new ::std::string;
  }
  gtport_->assign(value);
}
inline void TradeLog::set_gtport(const char* value, size_t size) {
  set_has_gtport();
  if (gtport_ == &::google::protobuf::internal::kEmptyString) {
    gtport_ = new ::std::string;
  }
  gtport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_gtport() {
  set_has_gtport();
  if (gtport_ == &::google::protobuf::internal::kEmptyString) {
    gtport_ = new ::std::string;
  }
  return gtport_;
}
inline ::std::string* TradeLog::release_gtport() {
  clear_has_gtport();
  if (gtport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gtport_;
    gtport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string recvtime = 10;
inline bool TradeLog::has_recvtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TradeLog::set_has_recvtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TradeLog::clear_has_recvtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TradeLog::clear_recvtime() {
  if (recvtime_ != &::google::protobuf::internal::kEmptyString) {
    recvtime_->clear();
  }
  clear_has_recvtime();
}
inline const ::std::string& TradeLog::recvtime() const {
  return *recvtime_;
}
inline void TradeLog::set_recvtime(const ::std::string& value) {
  set_has_recvtime();
  if (recvtime_ == &::google::protobuf::internal::kEmptyString) {
    recvtime_ = new ::std::string;
  }
  recvtime_->assign(value);
}
inline void TradeLog::set_recvtime(const char* value) {
  set_has_recvtime();
  if (recvtime_ == &::google::protobuf::internal::kEmptyString) {
    recvtime_ = new ::std::string;
  }
  recvtime_->assign(value);
}
inline void TradeLog::set_recvtime(const char* value, size_t size) {
  set_has_recvtime();
  if (recvtime_ == &::google::protobuf::internal::kEmptyString) {
    recvtime_ = new ::std::string;
  }
  recvtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_recvtime() {
  set_has_recvtime();
  if (recvtime_ == &::google::protobuf::internal::kEmptyString) {
    recvtime_ = new ::std::string;
  }
  return recvtime_;
}
inline ::std::string* TradeLog::release_recvtime() {
  clear_has_recvtime();
  if (recvtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recvtime_;
    recvtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string begintime = 11;
inline bool TradeLog::has_begintime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TradeLog::set_has_begintime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TradeLog::clear_has_begintime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TradeLog::clear_begintime() {
  if (begintime_ != &::google::protobuf::internal::kEmptyString) {
    begintime_->clear();
  }
  clear_has_begintime();
}
inline const ::std::string& TradeLog::begintime() const {
  return *begintime_;
}
inline void TradeLog::set_begintime(const ::std::string& value) {
  set_has_begintime();
  if (begintime_ == &::google::protobuf::internal::kEmptyString) {
    begintime_ = new ::std::string;
  }
  begintime_->assign(value);
}
inline void TradeLog::set_begintime(const char* value) {
  set_has_begintime();
  if (begintime_ == &::google::protobuf::internal::kEmptyString) {
    begintime_ = new ::std::string;
  }
  begintime_->assign(value);
}
inline void TradeLog::set_begintime(const char* value, size_t size) {
  set_has_begintime();
  if (begintime_ == &::google::protobuf::internal::kEmptyString) {
    begintime_ = new ::std::string;
  }
  begintime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_begintime() {
  set_has_begintime();
  if (begintime_ == &::google::protobuf::internal::kEmptyString) {
    begintime_ = new ::std::string;
  }
  return begintime_;
}
inline ::std::string* TradeLog::release_begintime() {
  clear_has_begintime();
  if (begintime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = begintime_;
    begintime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 runtime = 12;
inline bool TradeLog::has_runtime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TradeLog::set_has_runtime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TradeLog::clear_has_runtime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TradeLog::clear_runtime() {
  runtime_ = GOOGLE_LONGLONG(0);
  clear_has_runtime();
}
inline ::google::protobuf::int64 TradeLog::runtime() const {
  return runtime_;
}
inline void TradeLog::set_runtime(::google::protobuf::int64 value) {
  set_has_runtime();
  runtime_ = value;
}

// required string sendtime = 13;
inline bool TradeLog::has_sendtime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TradeLog::set_has_sendtime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TradeLog::clear_has_sendtime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TradeLog::clear_sendtime() {
  if (sendtime_ != &::google::protobuf::internal::kEmptyString) {
    sendtime_->clear();
  }
  clear_has_sendtime();
}
inline const ::std::string& TradeLog::sendtime() const {
  return *sendtime_;
}
inline void TradeLog::set_sendtime(const ::std::string& value) {
  set_has_sendtime();
  if (sendtime_ == &::google::protobuf::internal::kEmptyString) {
    sendtime_ = new ::std::string;
  }
  sendtime_->assign(value);
}
inline void TradeLog::set_sendtime(const char* value) {
  set_has_sendtime();
  if (sendtime_ == &::google::protobuf::internal::kEmptyString) {
    sendtime_ = new ::std::string;
  }
  sendtime_->assign(value);
}
inline void TradeLog::set_sendtime(const char* value, size_t size) {
  set_has_sendtime();
  if (sendtime_ == &::google::protobuf::internal::kEmptyString) {
    sendtime_ = new ::std::string;
  }
  sendtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_sendtime() {
  set_has_sendtime();
  if (sendtime_ == &::google::protobuf::internal::kEmptyString) {
    sendtime_ = new ::std::string;
  }
  return sendtime_;
}
inline ::std::string* TradeLog::release_sendtime() {
  clear_has_sendtime();
  if (sendtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendtime_;
    sendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string enc_request = 14;
inline bool TradeLog::has_enc_request() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TradeLog::set_has_enc_request() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TradeLog::clear_has_enc_request() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TradeLog::clear_enc_request() {
  if (enc_request_ != &::google::protobuf::internal::kEmptyString) {
    enc_request_->clear();
  }
  clear_has_enc_request();
}
inline const ::std::string& TradeLog::enc_request() const {
  return *enc_request_;
}
inline void TradeLog::set_enc_request(const ::std::string& value) {
  set_has_enc_request();
  if (enc_request_ == &::google::protobuf::internal::kEmptyString) {
    enc_request_ = new ::std::string;
  }
  enc_request_->assign(value);
}
inline void TradeLog::set_enc_request(const char* value) {
  set_has_enc_request();
  if (enc_request_ == &::google::protobuf::internal::kEmptyString) {
    enc_request_ = new ::std::string;
  }
  enc_request_->assign(value);
}
inline void TradeLog::set_enc_request(const char* value, size_t size) {
  set_has_enc_request();
  if (enc_request_ == &::google::protobuf::internal::kEmptyString) {
    enc_request_ = new ::std::string;
  }
  enc_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_enc_request() {
  set_has_enc_request();
  if (enc_request_ == &::google::protobuf::internal::kEmptyString) {
    enc_request_ = new ::std::string;
  }
  return enc_request_;
}
inline ::std::string* TradeLog::release_enc_request() {
  clear_has_enc_request();
  if (enc_request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enc_request_;
    enc_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string request = 15;
inline bool TradeLog::has_request() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TradeLog::set_has_request() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TradeLog::clear_has_request() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TradeLog::clear_request() {
  if (request_ != &::google::protobuf::internal::kEmptyString) {
    request_->clear();
  }
  clear_has_request();
}
inline const ::std::string& TradeLog::request() const {
  return *request_;
}
inline void TradeLog::set_request(const ::std::string& value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void TradeLog::set_request(const char* value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void TradeLog::set_request(const char* value, size_t size) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_request() {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  return request_;
}
inline ::std::string* TradeLog::release_request() {
  clear_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_;
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 status = 16;
inline bool TradeLog::has_status() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TradeLog::set_has_status() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TradeLog::clear_has_status() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TradeLog::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 TradeLog::status() const {
  return status_;
}
inline void TradeLog::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required string retcode = 17;
inline bool TradeLog::has_retcode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TradeLog::set_has_retcode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TradeLog::clear_has_retcode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TradeLog::clear_retcode() {
  if (retcode_ != &::google::protobuf::internal::kEmptyString) {
    retcode_->clear();
  }
  clear_has_retcode();
}
inline const ::std::string& TradeLog::retcode() const {
  return *retcode_;
}
inline void TradeLog::set_retcode(const ::std::string& value) {
  set_has_retcode();
  if (retcode_ == &::google::protobuf::internal::kEmptyString) {
    retcode_ = new ::std::string;
  }
  retcode_->assign(value);
}
inline void TradeLog::set_retcode(const char* value) {
  set_has_retcode();
  if (retcode_ == &::google::protobuf::internal::kEmptyString) {
    retcode_ = new ::std::string;
  }
  retcode_->assign(value);
}
inline void TradeLog::set_retcode(const char* value, size_t size) {
  set_has_retcode();
  if (retcode_ == &::google::protobuf::internal::kEmptyString) {
    retcode_ = new ::std::string;
  }
  retcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_retcode() {
  set_has_retcode();
  if (retcode_ == &::google::protobuf::internal::kEmptyString) {
    retcode_ = new ::std::string;
  }
  return retcode_;
}
inline ::std::string* TradeLog::release_retcode() {
  clear_has_retcode();
  if (retcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = retcode_;
    retcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string retmsg = 18;
inline bool TradeLog::has_retmsg() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TradeLog::set_has_retmsg() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TradeLog::clear_has_retmsg() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TradeLog::clear_retmsg() {
  if (retmsg_ != &::google::protobuf::internal::kEmptyString) {
    retmsg_->clear();
  }
  clear_has_retmsg();
}
inline const ::std::string& TradeLog::retmsg() const {
  return *retmsg_;
}
inline void TradeLog::set_retmsg(const ::std::string& value) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(value);
}
inline void TradeLog::set_retmsg(const char* value) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(value);
}
inline void TradeLog::set_retmsg(const char* value, size_t size) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_retmsg() {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  return retmsg_;
}
inline ::std::string* TradeLog::release_retmsg() {
  clear_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = retmsg_;
    retmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string response = 19;
inline bool TradeLog::has_response() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TradeLog::set_has_response() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TradeLog::clear_has_response() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TradeLog::clear_response() {
  if (response_ != &::google::protobuf::internal::kEmptyString) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& TradeLog::response() const {
  return *response_;
}
inline void TradeLog::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void TradeLog::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void TradeLog::set_response(const char* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    response_ = new ::std::string;
  }
  return response_;
}
inline ::std::string* TradeLog::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string enc_response = 20;
inline bool TradeLog::has_enc_response() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TradeLog::set_has_enc_response() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TradeLog::clear_has_enc_response() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TradeLog::clear_enc_response() {
  if (enc_response_ != &::google::protobuf::internal::kEmptyString) {
    enc_response_->clear();
  }
  clear_has_enc_response();
}
inline const ::std::string& TradeLog::enc_response() const {
  return *enc_response_;
}
inline void TradeLog::set_enc_response(const ::std::string& value) {
  set_has_enc_response();
  if (enc_response_ == &::google::protobuf::internal::kEmptyString) {
    enc_response_ = new ::std::string;
  }
  enc_response_->assign(value);
}
inline void TradeLog::set_enc_response(const char* value) {
  set_has_enc_response();
  if (enc_response_ == &::google::protobuf::internal::kEmptyString) {
    enc_response_ = new ::std::string;
  }
  enc_response_->assign(value);
}
inline void TradeLog::set_enc_response(const char* value, size_t size) {
  set_has_enc_response();
  if (enc_response_ == &::google::protobuf::internal::kEmptyString) {
    enc_response_ = new ::std::string;
  }
  enc_response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_enc_response() {
  set_has_enc_response();
  if (enc_response_ == &::google::protobuf::internal::kEmptyString) {
    enc_response_ = new ::std::string;
  }
  return enc_response_;
}
inline ::std::string* TradeLog::release_enc_response() {
  clear_has_enc_response();
  if (enc_response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enc_response_;
    enc_response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ip = 21;
inline bool TradeLog::has_ip() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TradeLog::set_has_ip() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TradeLog::clear_has_ip() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TradeLog::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& TradeLog::ip() const {
  return *ip_;
}
inline void TradeLog::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TradeLog::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void TradeLog::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* TradeLog::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string funcid = 22;
inline bool TradeLog::has_funcid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TradeLog::set_has_funcid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TradeLog::clear_has_funcid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TradeLog::clear_funcid() {
  if (funcid_ != &::google::protobuf::internal::kEmptyString) {
    funcid_->clear();
  }
  clear_has_funcid();
}
inline const ::std::string& TradeLog::funcid() const {
  return *funcid_;
}
inline void TradeLog::set_funcid(const ::std::string& value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void TradeLog::set_funcid(const char* value) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(value);
}
inline void TradeLog::set_funcid(const char* value, size_t size) {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  funcid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_funcid() {
  set_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    funcid_ = new ::std::string;
  }
  return funcid_;
}
inline ::std::string* TradeLog::release_funcid() {
  clear_has_funcid();
  if (funcid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = funcid_;
    funcid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string counterType = 23;
inline bool TradeLog::has_countertype() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TradeLog::set_has_countertype() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TradeLog::clear_has_countertype() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TradeLog::clear_countertype() {
  if (countertype_ != &::google::protobuf::internal::kEmptyString) {
    countertype_->clear();
  }
  clear_has_countertype();
}
inline const ::std::string& TradeLog::countertype() const {
  return *countertype_;
}
inline void TradeLog::set_countertype(const ::std::string& value) {
  set_has_countertype();
  if (countertype_ == &::google::protobuf::internal::kEmptyString) {
    countertype_ = new ::std::string;
  }
  countertype_->assign(value);
}
inline void TradeLog::set_countertype(const char* value) {
  set_has_countertype();
  if (countertype_ == &::google::protobuf::internal::kEmptyString) {
    countertype_ = new ::std::string;
  }
  countertype_->assign(value);
}
inline void TradeLog::set_countertype(const char* value, size_t size) {
  set_has_countertype();
  if (countertype_ == &::google::protobuf::internal::kEmptyString) {
    countertype_ = new ::std::string;
  }
  countertype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeLog::mutable_countertype() {
  set_has_countertype();
  if (countertype_ == &::google::protobuf::internal::kEmptyString) {
    countertype_ = new ::std::string;
  }
  return countertype_;
}
inline ::std::string* TradeLog::release_countertype() {
  clear_has_countertype();
  if (countertype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = countertype_;
    countertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Trade

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Trade::TradeLog_LogLevel>() {
  return ::Trade::TradeLog_LogLevel_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tradelog_2eproto__INCLUDED
